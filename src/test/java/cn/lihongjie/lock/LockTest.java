package cn.lihongjie.lock;

import org.junit.Test;

/**
 *
 * 实现一个锁的原理是控制系统线程的调度, 那么我们可以从两个层面来做:
 * 1. 内核层面
 *      线程调度的原理是中断, 那么我们可以在某一个线程执行的时候禁止系统中断, 那么我们就确保了在线程执行过程中是一个单线程的状态
 *      在这个层面实现主要有两个问题:
 *         1. 安全性问题: 操作系统不可能让用户的程序操作系统中断的
 *         2. 可用性的问题: 在多核操作系统上, 中断一个核的中断并不能禁止其他核运行线程
 * 2. 用户层面
 *       系统线程的调度用户程序一概不关心, 只需要在线程执行的时候进行处理, 如: 轮询, 休眠等方式阻止线程进入临界区
 *
 *       轮询的方式: 自旋锁, 使线程保持在   运行状态<->运行状态
 *           test and set
 *           compare and swap
 *       while(pull condition no match){
 *
 *       }
 *       轮询当前的锁状态, 并在合适的状态下更新锁
 *       主要有两个问题:
 *           1. 公平性: 轮询的线程可能永远拿不到锁
 *           2. 性能: 自旋锁浪费CPU性能
 *
 *
 *       为了解决自旋锁性能的问题, 当需要轮询的时候, 直接通过yield放弃CPU   运行状态 <-> 就绪状态
 *       while(pull condition no match){
 *          yield()
 *       }
 *
 *
 *       这种方法会导致上下切换, 代价同样很大, 同时CPU如果调度了就绪状态的线程到运行状态, 而这个线程决定放弃CPU, 那么就浪费了两次上下文切换
 *
 *
 *
 *       为了解决yield方法导致的无效上下文切换, 我们需要把等待锁的线程自己调度, 不能转交给操作系统.
 *          addToWaitQueue()   // 自己控制线程调度
 *          sleep()
 *
 *      在JAVA中的实现就是AbstractQueuedSynchronizer
 *
 *
 * 不管从哪个层面实现, 锁必须的实现安全的, 我们不可能用一个锁去保护另一个锁.
 * 为了实现锁, 我们需要借助硬件指令作为最基础的指令
 * @author 982264618@qq.com
 */
public class LockTest {


	@Test
	public void name() throws Exception {

	}
}
